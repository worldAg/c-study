#include <stdio.h>

int main(void)
{
	/* 컴퓨터의 연산 처리 과정
		1. 변수는 데이터를 저장하는 메모리(RAM)에 존재하며, 연산할 때는 메모리에 있는 변수의 값을 CPU의 저장 공간인 레지스터에 복사. 이 과정을 로드(load)라고 함.
		2. 데이터가 레지스터에 저장되면 연산 장치인 ALU에 의해 연산이 수행되고, 그 결괏값은 일단 레지스터에 저장됨.
		3. 이후 대입 연산을 수행하면서 메모리 공간인 해당 변수에 복사되어(이 과정을 스토어(store)) 수식의 모든 과정 종료됨.

		CPU의 메모리 레지스터
		- 레지스터는 연산할 데이터와 연산 후의 결과를 임시 저장
		- 일반적으로 레지스터는 CPU 클럭과 1:1 동기화되어 있어 메모리(RAM)에 비해 상당히 빠르다는 장점 지님
		- 그러나 다음 연산을 위해 계속 사용되므로 연산 결과를 메모리로 옮기지 않으면 그 값이 사라짐(즉 연산 결과를 바로 사용하거나, 대입 연산을 통해 변수에 저장해야 함)
	*/
	/* 연산자 우선 순위
		1. 괄호: ()
		2. 단항: ++, --, ~, !
		3. 산술: *, /, +, -
		4. 비트 이동: <<, >>
		5. 비교: <, <=, >, >=
		6. 관계: ==, !=
		7. 비트 논리: &, ^, |
		8. 논리: &&, ||
		9. 대입: =, +=, -=, *=, /=, %=
	*/

	/* 산술 연산자(Arithmetic Operators)
		- 나눗셈 연산자(/)는 정수로 연산할 때 몫을 구하고 실수로 연산할 때는 소수점까지 구함
		- 나머지 연산자(%)는 몫을 뺀 나머지를 구하는데, 실수 연산에는 나머지 개념이 없으므로 정수 연산에만 사용
	*/
	int a, b, sum, sub, mul, div1, rem, inv;
	double div2;

	a = 5;
	b = 2;

	sum = a + b;
	sub = a - b;
	mul = a * b;
	div1 = a / b;
	div2 = ((double)a) / ((double)b); // 실수로 형변환하여 나누기 연산
	rem = a % b;
	inv = -a; // 음수 연산 후 대입 연산

	printf("덧셈: %d\n", sum);            // 덧셈: 30
	printf("뺄셈: %d\n", sub);            // 뺄셈: -10
	printf("곱셈: %d\n", mul);            // 곱셈: 200
	printf("정수 나눗셈: %d\n", div1);    // 정수 나눗셈: 2
	printf("실수 나눗셈: %.1lf\n", div2); // 실수 나눗셈: 2.5
	printf("나머지 연산: %d\n", rem);     // 나머지 연산: 1
	printf("a의 음수 연산: %d\n", inv);   // a의 음수 연산: -10
	printf("------------------------------\n");


	/* 증감 연산자(Increment and Decrement Operators)
		- 대입 연산을 포함하므로 피연산자의 값이 변경됨
		- 전위형(prefix)은 증감하고 나서 연산에 사용하고, 후위형(postfix)은 연산에 사용하고 증감
	*/
	int pre, post;

	a = 5, b = 5;
	pre = (++a) * 3;
	post = (b++) * 3;

	printf("a = %d, b = %d\n", a, b);                                      // a = 6, b = 6
	printf("전위형: (++a) * 3 = %d, 후위형: (b++) * 3 = %d\n", pre, post); // 전위형: (++a) * 3 = 18, 후위형: (b++) * 3 = 15
	printf("------------------------------\n");


	/* 대입 연산자
		- 대입 연산자의 왼쪽에는 변수. 즉 변수의 공간.
		- 대입 연산자의 오른쪽은 변수에 넣을 값. 즉 변수 공간의 값.
		- 변수가 공간으로 쓰일 때는 l-value(left-value), 값으로 쓰일 때는 r-value(right-value)라고 함. l-value와 r-value는 컴파일 시 기계어도 다르게 변환 됨.
	*/
	int c, d;
	c = 1; // 여기서 변수 c(l-value)는 변수의 공간으로 쓰임.
	d = c; // 여기서 변수 c(r-value)는 변수 공간의 값으로 쓰임. d에는 c의 값 1 대입.


	/* 복합 대입 연산자 
		- 연산 결과를 다시 피연산자에 저장
	*/
	a = 1, b = 2;
	int res = 10;

	a += 9;        // a와 9를 더한 결과를 다시 a에 저장(a = a + 9 = 10)
	res *= b + 10; // b에 10을 더한 결괏값에 res를 곱하고 다시 res에 저장(res = res * (b + 10) = 120)

	printf("a = %d, b = %d, res = %d\n", a, b, res); // a = 10, b = 2, res = 120
	printf("------------------------------\n");


	/* 관계 연산자(Relational Operators)
		- 관계 연산자의 결괏값은 1 또는 0.
		- 컴파일러는 0은 거짓, 0이 아닌 값은 참으로 판단하므로 관계식을 실행 조건 검사에 사용 가능.
	*/
	a = 10, b = 20, c = 10;

	printf("a > b: %d\n", a > b);   // a > b: 0
	printf("a >= b: %d\n", a >= b); // a >= b: 0
	printf("a < b: %d\n", a < b);   // a < b: 1
	printf("a <= b: %d\n", a <= b); // a <= b: 1
	printf("a <= c: %d\n", a <= c); // a <= c: 1
	printf("a == b: %d\n", a == b); // a == b: 0
	printf("a != c: %d\n", a != c); // a != c: 0
	printf("------------------------------\n");


	/* 논리 연산자(Logical Operators)
		• && : 논리곱(AND). 모두 참일 때 참.
		• || : 논리합(OR). 둘 중 하나라도 참이면 참.
		•  ! : 논리부정(NOT). 참이면 거짓. 거짓이면 참.
		(*참은 1. 거짓은 0.)

		- &&와 || 연산자는 숏 서킷 룰(short circuit rule) 적용되어 좌항만으로 연산 결과를 판별함
	*/
	a = 5;

	printf("(a > 4) && (a > 3): %d\n", (a > 4) && (a > 3)); // (a > 4) && (a > 3): 1
	printf("0 && (a > 3): %d\n", 0 && (a > 3));             // 0 && (a > 3): 0       // && 연산에서 좌항이 이미 거짓(0)이므로 우항은 실행하지 않고 결과 0.
	printf("(a > 4) || (a > 3): %d\n", (a > 4) || (a > 3)); // (a > 4) || (a > 3): 1 // || 연산에서 좌항이 이미 참이므로 우항은 실행하지 않고 결과 1.
	printf("(a > 6) || (a > 3): %d\n", (a > 6) || (a > 3)); // (a > 6) || (a > 3): 1
	printf("(a > 6) || (a > 7): %d\n", (a > 6) || (a > 7)); // (a > 6) || (a > 7): 0
	printf("!(a > 6): %d\n", !(a > 6));                     // !(a > 6): 1


	return 0;
}